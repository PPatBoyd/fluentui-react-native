import * as React from 'react';
import { TouchableOpacity, ScreenRect, Text, View, Switch, Picker, ScrollView } from 'react-native';
import { Callout, Separator, RestoreFocusEvent } from '@fluentui/react-native';
import { fabricTesterStyles } from '../Common/styles';
import { CALLOUT_TESTPAGE } from './consts';

export const CalloutTest: React.FunctionComponent<{}> = () => {
  const [showStandardCallout, setShowStandardCallout] = React.useState(false);
  const [showCustomizedCallout, setShowCustomizedCallout] = React.useState(false);
  const [isStandardCalloutVisible, setIsStandardCalloutVisible] = React.useState(false);
  const [isCustomizedCalloutVisible, setIsCustomizedCalloutVisible] = React.useState(false);

  const [shouldSetInitialFocus, setShouldSetInitialFocus] = React.useState(true);
  const onInitialFocusChange = React.useCallback((value) => setShouldSetInitialFocus(value), []);

  const [customRestoreFocus, setCustomRestoreFocus] = React.useState(false);
  const onRestoreFocusChange = React.useCallback((value) => setCustomRestoreFocus(value), []);

  const [isBeakVisible, setIsBeakVisible] = React.useState(false);
  const onIsBeakVisibleChange = React.useCallback((value) => setIsBeakVisible(value), []);

  const redTargetRef = React.useRef<View>(null);
  const blueTargetRef = React.useRef<View>(null);
  const greenTargetRef = React.useRef<View>(null);
  const decoyBtn1Ref = React.useRef(null);
  const decoyBtn2Ref = React.useRef(null);
  const [anchorRef, setAnchorRef] = React.useState(redTargetRef);

  const toggleShowStandardCallout = React.useCallback(() => {
    setShowStandardCallout(!showStandardCallout);

    // Unmounting a callout does not invoke onDismiss; onDismiss is only invoked
    // for dismissals generated by the native app.  When toggling to 'show',
    // the isVisible state will be corrected to 'true' by the onShow callback.
    setIsStandardCalloutVisible(false);
  }, [showStandardCallout, setIsStandardCalloutVisible, setShowStandardCallout]);

  const toggleShowCustomizedCallout = React.useCallback(() => {
    setShowCustomizedCallout(!showCustomizedCallout);

    // Unmounting a callout does not invoke onDismiss; onDismiss is only invoked
    // for dismissals generated by the native app.  When toggling to 'show',
    // the isVisible state will be corrected to 'true' by the onShow callback.
    setIsCustomizedCalloutVisible(false);
  }, [showCustomizedCallout, setIsCustomizedCalloutVisible, setShowCustomizedCallout]);

  const toggleCalloutRef = React.useCallback(() => {
    // Cycle the target ref between the RGB target views
    setAnchorRef(anchorRef === redTargetRef ? greenTargetRef : anchorRef === greenTargetRef ? blueTargetRef : redTargetRef);
  }, [anchorRef, setAnchorRef]);

  const onShowStandardCallout = React.useCallback(() => {
    setIsStandardCalloutVisible(true);
  }, [setIsStandardCalloutVisible]);

  const onShowCustomizedCallout = React.useCallback(() => {
    setIsCustomizedCalloutVisible(true);
  }, [setIsCustomizedCalloutVisible]);

  const onDismissStandardCallout = React.useCallback(() => {
    setIsStandardCalloutVisible(false);

    // setting the internal state to false will instigate unmounting the
    // zombie Callout control.
    setShowStandardCallout(false);
  }, [setIsStandardCalloutVisible, setShowStandardCallout]);

  const onDismissCustomizedCallout = React.useCallback(() => {
    setIsCustomizedCalloutVisible(false);

    // setting the internal state to false will instigate unmounting the
    // zombie Callout control.
    setShowCustomizedCallout(false);
  }, [setIsCustomizedCalloutVisible, setShowCustomizedCallout]);

  const onRestoreFocusStandardCallout = React.useCallback(
    (restoreFocusEvent: RestoreFocusEvent) => {
      if (restoreFocusEvent?.nativeEvent?.containsFocus) {
        decoyBtn1Ref?.current?.focus?.();
      } else {
        decoyBtn2Ref?.current?.focus?.();
      }
    },
    [decoyBtn1Ref, decoyBtn2Ref]
  );

  const colorDefault: string = 'default';
  const colorSelections: string[] = [colorDefault, 'red', 'green', 'blue'];

  const [selectedBackgroundColor, setSelectedBackgroundColor] = React.useState<string | undefined>(undefined);
  const [selectedBorderColor, setSelectedBorderColor] = React.useState<string | undefined>(undefined);

  const borderWidthDefault: string = 'default (1)';
  const borderWidthSelections: (number | string)[] = ['default (1)', 2, 4, 10];

  const [selectedBorderWidth, setSelectedBorderWidth] = React.useState<string | undefined>(undefined);

  const myRect: ScreenRect = { screenX: 10, screenY: 10, width: 100, height: 100 };

  const [countOfColors, setCountOfColors] = React.useState(1);

  const renderColors = () => {
    return (
      <View>
        <View style={{ height: 100, width: 100, backgroundColor: 'red', padding: 5 }} />
        <View style={{ height: 100, width: 100, backgroundColor: 'green', padding: 5 }} />
        <View style={{ height: 100, width: 100, backgroundColor: 'blue', padding: 5 }} />
      </View>
    );
  };

  const colorStrip = [];
  for (let i = 0; i < countOfColors; i++) {
    colorStrip.push(renderColors());
  }

  return (
    <View>
      <Text style={fabricTesterStyles.testSection} testID={CALLOUT_TESTPAGE}>
        Standard Usage
      </Text>
      <Separator />
      <View style={{ flexDirection: 'row', paddingVertical: 5 }}>
        <View style={{ flexDirection: 'column', paddingHorizontal: 5 }}>
          <View style={{ flexDirection: 'row' }}>
            <Switch value={shouldSetInitialFocus} onValueChange={onInitialFocusChange} />
            <Text>Set Initial Focus</Text>
          </View>

          <View style={{ flexDirection: 'row' }}>
            <Switch value={customRestoreFocus} onValueChange={onRestoreFocusChange} />
            <Text>Customize Restore Focus</Text>
          </View>

          <View style={{ flexDirection: 'row' }}>
            <Switch value={isBeakVisible} onValueChange={onIsBeakVisibleChange} />
            <Text>Beak Visible</Text>
          </View>
          <Picker
            prompt="Background Color"
            selectedValue={selectedBackgroundColor || colorDefault}
            onValueChange={(color) => setSelectedBackgroundColor(color === colorDefault ? undefined : color)}
          >
            {colorSelections.map((color, index) => (
              <Picker.Item label={color} key={index} value={color} />
            ))}
          </Picker>

          <Picker
            prompt="Border Color"
            selectedValue={selectedBorderColor || colorDefault}
            onValueChange={(color) => setSelectedBorderColor(color === colorDefault ? undefined : color)}
          >
            {colorSelections.map((color, index) => (
              <Picker.Item label={color} key={index} value={color} />
            ))}
          </Picker>

          <Picker
            prompt="Border Width"
            selectedValue={selectedBorderWidth || borderWidthDefault}
            onValueChange={(width) => setSelectedBorderWidth(width === borderWidthDefault ? undefined : width)}
          >
            {borderWidthSelections.map((width, index) => (
              <Picker.Item label={width.toString()} key={index} value={width} />
            ))}
          </Picker>
        </View>

        <Separator vertical />

        <View style={{ flexDirection: 'column', paddingHorizontal: 5 }}>
          <TouchableOpacity onPress={toggleShowStandardCallout}>
            <Text>Press for Callout</Text>
          </TouchableOpacity>
          <Text>
            <Text>Visibility: </Text>
            {isStandardCalloutVisible ? <Text style={{ color: 'green' }}>Visible</Text> : <Text style={{ color: 'red' }}>Not Visible</Text>}
          </Text>
        </View>

        <Separator vertical />

        <View style={{ flexDirection: 'column', paddingHorizontal: 5 }}>
          <View ref={redTargetRef} style={{ height: 20, width: 20, backgroundColor: 'red', padding: 5 }} />
          <View ref={greenTargetRef} style={{ height: 20, width: 20, backgroundColor: 'green', padding: 5 }} />
          <View ref={blueTargetRef} style={{ height: 20, width: 20, backgroundColor: 'blue', padding: 5 }} />
        </View>
      </View>

      <Separator />

      <View style={{ paddingVertical: 5 }}>
        <TouchableOpacity ref={decoyBtn1Ref}>
          <Text>asd</Text>
        </TouchableOpacity>
        <TouchableOpacity ref={decoyBtn2Ref}>
          <Text>asdasd</Text>
        </TouchableOpacity>
      </View>

      {showStandardCallout && (
        <Callout
          {...{
            target: anchorRef,
            onDismiss: onDismissStandardCallout,
            onShow: onShowStandardCallout,
            ...(customRestoreFocus && { onRestoreFocus: onRestoreFocusStandardCallout }),
            accessibilityLabel: 'Standard Callout',
            setInitialFocus: shouldSetInitialFocus,
            isBeakVisible: isBeakVisible,
            ...(selectedBorderColor && { borderColor: selectedBorderColor }),
            ...(selectedBackgroundColor && { backgroundColor: selectedBackgroundColor }),
            ...(selectedBorderWidth && { borderWidth: selectedBorderWidth }),
          }}
        >
          <View style={{ padding: 20 }}>
            <ScrollView showsVerticalScrollIndicator style={{ flexDirection: 'column', minWidth: 200 }}>
              <TouchableOpacity onPress={toggleCalloutRef}>
                <Text>Change Anchor</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={() => {
                  setCountOfColors(countOfColors + 1);
                }}
              >
                <Text>Click to Grow</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={() => {
                  setCountOfColors(countOfColors - 1);
                }}
              >
                <Text>Click to Shrink</Text>
              </TouchableOpacity>
              {colorStrip}
            </ScrollView>
          </View>
        </Callout>
      )}

      <Text style={fabricTesterStyles.testSection}>Customized Usage</Text>
      <Separator />

      <View style={{ flexDirection: 'column', paddingVertical: 5 }}>
        <TouchableOpacity onPress={toggleShowCustomizedCallout}>
          <Text>asdasd</Text>
        </TouchableOpacity>
        <Text selectable={true}>
          <Text>Visibility: </Text>
          {isCustomizedCalloutVisible ? <Text style={{ color: 'green' }}>Visible</Text> : <Text style={{ color: 'red' }}>Not Visible</Text>}
        </Text>
      </View>

      {showCustomizedCallout && (
        <Callout
          anchorRect={myRect}
          onDismiss={onDismissCustomizedCallout}
          onShow={onShowCustomizedCallout}
          accessibilityLabel="Customized Callout"
          accessibilityRole="alert"
          accessibilityOnShowAnnouncement="Be informed that a customized callout has been opened."
        >
          <View style={{ padding: 20, borderWidth: 2, borderColor: 'black' }}>
            <Text>just some text so it does not take focus and is not empty.</Text>
          </View>
        </Callout>
      )}
    </View>
  );
};
